# 3way handshake란?

TCP 통신이 원활하게 이뤄지기 위해 통신을 준비하는 단계.   
이 단계가 정상적으로 끝난 이후부터 통신이 시작된다.

## 왜 3way handshake인가?

양쪽 끝에 있는 컴퓨터는 서로 sequence number를 통해 데이터를 트래킹한다.    
이 과정을 통해 신뢰성 있는 연결(데이터 전송)을 보장해준다.

![image](https://user-images.githubusercontent.com/128302413/233668175-29021dcf-7368-4f26-9cee-55a5434671b3.png)

1 . 클라이언트에서 SYN 과 seq No 를 보낸다.
- 이 seq no를 통해 데이터의 순서를 알 수 있고, 어떤 데이터가 빠졌는 지 알 수 있다.
- 이 값은 0부터 시작이아니라 임의로 만들어진 숫자부터 시작한다. (이 그림에서는 x)

2 . 서버는 SYN에서 seq no를 받고, 1을 더한값을 ACK에 보내 seq no을 정상적으로 받았음을 알린다.   
또한, 그 패킷에 SYN값과 서버쪽의 seq no를 만들어서 보낸다. (그림에서 y)
- 양쪽(서버, 클라이언트)에서 seq no를 보내준다. 서로 이 숫자로 데이터를 트래킹함.

3 . 클라이언트에서 ACK로 seq no+1(y+1)을 ACK로 보내서 서로의 통신이 잘 연결됬음을 확인한다.

# 4way handshake란?

TCP 통신을 끝낼 때 사용하는 프로토콜이다.    
양쪽에서 서로가 끝났음을 확인시키고 통신을 종료한다.

## 왜 4way handshake인가?

한쪽이 통신을 종료한다고 보낸다 하여도, 반대쪽에서 보내야할 데이터가 남아있을 수 있다.   
신뢰성있게 모든 데이터를 양쪽끝에서 보내고,    
더 이상 보낼 내용이 없을 때 양쪽다 통신을 끊기 위해 3way에서 1단계가 더 추가된다.

![image](https://user-images.githubusercontent.com/128302413/233668835-77d9fc00-3bbc-4c7f-b8e7-a2dd3d6d9d2a.png)

1 . 클라이언트에서 FIN으로 종료를 알린다. seq 역시 보내준다.
- 이제 클라이언트는 서버에서 아직 덜 보낸 내용만 더받기를 기다린다.
- 이 메시지 이후에는 클라이언트에서의 요청은 없다고 생각한다.

2 . 서버에서 ACK를 통해 FIN을 받았음을 알린다.
- u+1을 ACK로 보내 u를 받았음을 알린다.
- 서버에서 더 보낼 내용이 있을 수 있으므로, seq내용은 여기서는 v이나 후에 w(v+더보낼내용의 개수)가 된다.

3 . 서버도 보낼내용을 다보낸 상황. FIN을 보내고, 이 패킷에 맞는 seq (그림에서 w)를 같이보낸다.   
또한 클라이언트는 FIN으로 u를 보내고 더이상 보내지 않으므로 ACK는 여기서도 u+1이다.
클라이언트가 서버의 FIN을 받고, 마지막 메시지를 보내고 종료한다. 서버또한 이메시지를 받으면 통신을 종료한다.

4 . 클라이언트가 서버의 FIN을 받고, 마지막 메시지를 보내고 종료한다. 서버또한 이메시지를 받으면 통신을 종료한다.
